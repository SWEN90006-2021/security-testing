# SWEN90006: Security & Software Testing

This repository contains instructions to run examples in lectures 7-12. We use Docker that allows students to build and run examples in the same way regardless of their operating systems (e.g., Linux, Windows, or macOS).

# Installation

## Install Docker

Please follow [this instruction](https://docs.docker.com/get-docker/) to install Docker on your machine.

## Build a Docker image


We need to build a Docker image using the given Dockerfile. The Docker image has everything ready for our experiments. Once we make changes to the Dockerfile, we would need to rerun this command.
```bash
docker build . -t swen90006 --no-cache
```

**For Mac M1, M2 and M3 users**, before you run the above command, please edit the Dockerfile. On the first line of the Dockerfile: 

```bash
# comment out this line
FROM ubuntu:20.04
# Use the below line
FROM --platform=linux/amd64 ubuntu:20.04 
```


If the build is successful, we should have a new Docker image named swen90006. To see all Docker images on our computer, we can run the following command.
```bash
docker image ls
```

# Weekly Examples

Before start running an example, we need to start a Docker container using the successfully built Docker image
```bash
docker run -it swen90006 /bin/bash
```

## Week 7: Introduction to Security Testing
Compile a buggy program named check_pin. To demonstrate the stack overflow vulnerability in check_pin, we add the '-fno-stack-protector' option letting the compiler (gcc) to disable its stack protector.
```bash
cd $WORKDIR
gcc -o check_pin check_pin.c -fno-stack-protector
```

Run the random fuzzer to fuzz the check_pin example
```bash
cd $WORKDIR
random_fuzzer.sh ./check_pin 20 results-random
```

## Week 8: Mutation-based and Generation-based Blackbox Fuzzing

### Simple demo for mutation-based blackbox fuzzing
Run the mutation-based fuzzer to fuzz the check_pin example
```bash
cd $WORKDIR
mutation_fuzzer.sh ./check_pin 1234 20 results-mutation
```

### Fuzzing LibPNG using Generation-based Blackbox Fuzzing (e.g., Peach Fuzzer)
We fuzz test [LibPNG](http://www.libpng.org/pub/png/libpng.html), which is the official PNG reference library.
Compile the newest version of LibPNG. Once the compilation is done, all LibPNG utilities (e.g., pngimage) should be stored in the libpng folder.

```bash
cd $WORKDIR
git clone https://github.com/glennrp/libpng.git 
cd libpng
autoreconf -f -i
./configure --disable-shared
make clean all
```

Fuzzing pngimage, a specific utility in LibPNG, using Peach input generator with no seed inputs i.e. inputs are generated directly from a given input model.
```bash
cd $WORKDIR
generation_fuzzer.sh libpng/pngimage png_pit_no_seeds.xml 20 results-no-seeds
```

Fuzzing pngimage using Peach input generator with seed inputs which are stored in a folder named 'in'.
```bash
cd $WORKDIR
mkdir in
cp libpng/*.png in/
generation_fuzzer.sh libpng/pngimage png_pit.xml 20 results-with-seeds
```

## Week 9: Feedback-guided Greybox Fuzzing

### Fuzzing good_bad function using AFL

To fuzz test the good_bad function, we need to wrap it into a so-called test-driver which contains a main function as an entry point. The main function reads a file as input, read first 4 bytes from that file and pass it to the good_bad function. @@ is just a placeholder and it will be replaced by an actual input file generated by AFL.

```bash
cd $WORKDIR
afl-clang-fast -o good_bad_fuzz good_bad_fuzz.c
mkdir in-afl
echo "good" > in-afl/good.txt
afl-fuzz -d -i in-afl -o out-afl -- ./good_bad_fuzz @@
```

The generated inputs, including the crash-triggering ones should be avaialbel inside out-afl folder.

### Fuzzing LibPNG using Code Coverage-guided Greybox Fuzzing (e.g., American Fuzzy Lop (AFL))
Compile LibPNG with AFL instrumentation pass (afl-clang-fast) so that code coverage information can be dynamically collected while the program under test is running. Note that unlike Peach fuzzer, the vanilla AFL fuzzer cannot detect and fix integrity checks like checksums so we disable the checksum checks in the LibPNG source code by applying a simple patch.

```bash
cd $WORKDIR
git clone https://github.com/glennrp/libpng.git libpng-afl
cd libpng-afl
sed -i 's/return ((int)(crc != png_ptr->crc));/return (0);/g' pngrutil.c
autoreconf -f -i
CC=afl-clang-fast ./configure --disable-shared
make clean all
```

Fuzzing pngimage using AFL. AFL will take the sample inputs, mutate them, and store interesting inputs into an output folder. @@ is just a placeholder and it will be replaced by an actual input file generated by AFL.
```bash
cd $WORKDIR
afl-fuzz -i in -o out -- libpng-afl/pngimage @@
```

## Week 10: Symbolic Execution

Please note that in this experiment, we are using a separate Docker for KLEE instead of the default swen90006 one. To set it up, please run the following commands. Detailed instructions are copied from [KLEE webpage](https://klee-se.org/docker/).

```bash
docker pull klee/klee:3.0
docker run --rm -ti --ulimit='stack=-1:-1' klee/klee:3.0
```
After running this, we should see a prompt for KLEE like `klee@451c4bee278a` in which `451c4bee278a` is the ID to access the running Docker container. This ID is used in the following step.

### Copy necessary files to the KLEE docker
Make sure you use your correct container ID, which is changing over time
```bash
docker cp klee_swap.c 451c4bee278a:/home/klee/
docker cp klee_get_sign.c 451c4bee278a:/home/klee/
docker cp klee_pointer.c 451c4bee278a:/home/klee/
docker cp klee_maze.c 451c4bee278a:/home/klee/
```
### Symbolically running simple functions with KLEE
First we compile the programs which wrap the functions under analysis to LLVM bitcode.
```bash
clang -emit-llvm -c klee_swap.c
clang -emit-llvm -c klee_get_sign.c
clang -emit-llvm -c klee_pointer.c
```
And now we can run KLEE to symbolically execute these programs
```bash
klee klee_swap.bc
klee klee_get_sign.bc
klee klee_pointer.bc
```
All test cases and other outputs should be stored in the klee-last folder.

### Symbolically solve a maze with KLEE
We follow similar steps above to compile and run a maze program. This experiment is based on [this example](https://feliam.wordpress.com/2010/10/07/the-symbolic-maze/).

Compile the maze code to produce LLVM bitcode
```bash
clang -emit-llvm -c klee_maze.c
```

Then run KLEE to solve the maze and get the solutions automatically :)
```bash
klee --emit-all-errors klee_maze.bc
```

### Using Z3 solver
Run the example of solving shopping constraints with Z3 solver
```bash
python3 z3_demo.py
```

